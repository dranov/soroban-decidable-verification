#lang ivy1.8

#########################################
# Mappings (with transactional support) #
#########################################
module partial_map(dom,rng) = {
    relation map(X:dom,Y:rng)
    relation pre(X:dom) 

    # mutate the function so x maps to y
    action set(x:dom,y:rng)

    # remove an element from the pre-image
    action remove(x:dom)

    # get the value of x, if any
    action get(x:dom) returns (y:rng)

    # true if x is in the pre-image
    action has(x:dom) returns (r:bool)
    
    # if x in pre, there exists a y such that map(x,y)
    action img_lemma(x:dom)

    ######################
    # Transaction suport #
    ######################
    relation _map(X:dom,Y:rng)
    relation _pre(X:dom)
    action _save_state = {
        _map(X,Y) := map(X,Y);
        _pre(X) := pre(X)
    }
    action _restore_state = {
        map(X,Y) := _map(X,Y);
        pre(X) := _pre(X)
    }

    specification {
        after init {
            map(X,Y) := false
        }

        implement set {
            call img_lemma(x);
            map(x,Y) := Y = y;
            pre(x) := true
        }

        implement remove {
            call img_lemma(x);
            map(x,Y) := false;
            pre(x) := false
        }

        after get {
            assume pre(x) -> map(x,y)
        }

        after has {
            assume r = pre(x)
        }

        implement img_lemma(x:dom) {
            assume pre(x) -> exists Y. map(x,Y)
        }

        explicit invariant [img] pre(X) -> exists Y. map(X,Y)
    }

    conjecture [mapping_preimage] map(K, V) -> pre(K)
    conjecture [functionality] map(K,L) & map(K,M) -> L = M

    trusted isolate iso = this
}

# Singleton value -- effectively a map with a single key
module singleton(rng) = {
    individual is_set: bool
    individual v: rng

    action set(y:rng)
    action get returns (y:rng)
    action has returns (r:bool)

    ######################
    # Transaction suport #
    ######################
    individual _is_set: bool
    individual _v: rng
    action _save_state = {
        _is_set := is_set;
        _v := v
    }
    action _restore_state = {
        is_set := _is_set;
        v := _v
    }

    specification {
        after init {
            is_set := false
        }

        implement set {
            is_set := true;
            v := y
        }

        after get {
            assume is_set -> v = y
        }

        after has {
            assume r = is_set
        }
    }
}

# Copied from `order.ivy`; can `include order` instead
module unbounded_sequence = {
    type this
    alias t = this

    # returns the least key greater than x
    action next(x:t) returns (y:t)

    # returns the greatest key less than x
    action prev(x:t) returns (y:t)

    relation succ(X:t,Y:t)

    object spec = {
        property [transitivity] (T:t < U & U < V) -> (T < V)
        property [antisymmetry] ~(T:t < U & U < T)
        property [totality] T:t < U | T = U | U < T
        property [succ_def] succ(X,Z) -> (X < Z & ~(X < Y & Y < Z))
        property [zero_smallest] 0 <= X:t

        after next {
            assert x < y & (x < Y -> y <= Y);
            assert succ(x,y)
        }
        before prev {
            assert 0 < x
        }
        after prev {
            assert y < x & (Y < x -> Y <= y);
            assert succ(y,x)
        }
    }

    object impl = {
        interpret t -> nat
        definition succ(X,Y) = (Y = X + 1)
        implement next {
            y := x + 1
        }
        implement prev {
            y := x - 1
        }
    }
    isolate iso = impl,spec
}

module integer = {
    type this
    alias t = this

    individual zero : t
    relation succ(X:t,Y:t)

    relation plus(X:t,Y:t,Z:t)
    relation minus(X:t,Y:t,Z:t)

    action next(x:t) returns (y:t)
    action prev(x:t) returns (y:t)

    # function (X:t + Y:t) : t
    # function (X:t - Y:t) : t
    # A function is a relation with [functionality] and [totality]
    # axioms. We state the former and instantiate the latter on demand.
    action add(x:t,y:t) returns (z:t)
    action sub(x:t,y:t) returns (z:t)

    action add_lemma(x:t,y:t)
    action sub_lemma(x:t,y:t)

    object spec = {
        property [zero_eq_zero]
            zero = 0

        property [plus_functionality]
            plus(X, Y, Z1) & plus(X, Y, Z2) -> Z1 = Z2
        property [minus_functionality]
            minus(X, Y, Z1) & minus(X, Y, Z2) -> Z1 = Z2

        # Properties of addition
        property [plus_commutative]
            plus(X, Y, Z) -> plus(Y, X, Z)
        property [plus_associative]
            plus(A, B, AB) & plus (AB, C, ABC1) &
            plus(B, C, BC) & plus(A, BC, ABC2) -> ABC1 = ABC2
        property [plus_zero]
            plus(zero, X, X)
        property [plus_positive]
            plus(X, Y, Z) & Y > 0 -> X < Z

        # Properties of subtraction
        property [minus_zero]
            minus(X, zero, X)
        property [minus_self]
            minus(X, X, zero)

        # Properties of order
        property [transitivity] (T:t < U & U < V) -> (T < V)
        property [antisymmetry] ~(T:t < U & U < T)
        property [totality] T:t < U | T = U | U < T
        property [succ_def] succ(X,Z) -> (X < Z & ~(X < Y & Y < Z))

        implement add_lemma(x:t, y:t) {
            assume exists Z. plus(x, y, Z);
        }
        implement sub_lemma(x:t, y:t) {
            assume exists Z. minus(x, y, Z);
        }

        after add {
            assume plus(x, y, z);
        }
        after sub {
            assume minus(x, y, z);
        }
        after next {
            assert x < y & (x < Y -> y <= Y);
            assert succ(x,y)
        }
        after prev {
            assert y < x & (Y < x -> Y <= y);
            assert succ(y,x)
        }

    }

    object impl = {
        interpret t -> int
        definition zero = 0
        definition plus(X, Y, Z) = (Z = X + Y)
        definition minus(X, Y, Z) = (Z = X - Y)
        definition succ(X, Y) = (Y = X + 1)
    }
    isolate iso = impl,spec
}

##########################
# Stellar-specific types #
##########################
type address
instance ledger : unbounded_sequence
# interpret ledger -> nat

###############
# Environment #
###############

module environment(function_identifier) = {
    individual current_ledger : ledger

    # Keeps track of the context of a transaction
    individual tx_has_started: bool
    individual tx_has_panicked: bool

    # Authentication
    relation contract_addresses(A: address)
    # A must have authorized a call to contract C.F
    relation auth_required(A: address, C: address, F: function_identifier)

    after init {
        current_ledger := 0;
        tx_has_started := false;
        tx_has_panicked := false;
        contract_addresses(A) := false;
        auth_required(A,C,F) := false;
    }

    ##################
    # Authentication #
    ##################

    action _register_contract returns (a:address) = {
        # every contract must have a unique address
        assume ~contract_addresses(a);
        contract_addresses(a) := true;
    }

    action require_auth(a: address, c: address, f: function_identifier) = {
        auth_required(a, c, f) := true;
    }

    ##########################
    # Transaction management #
    ##########################

    action new_transaction = {
        tx_has_started := false;
        tx_has_panicked := false;
    }
    
    action begin_transaction = {
        require ~tx_has_started;
        tx_has_started := true;
    }

    # Transaction executor must restore initial state if transaction panics
    action end_transaction returns (restore_state:bool) = {
        # require tx_has_started;
        restore_state := false;
        if tx_has_panicked {
            restore_state := true;
        }
        call new_transaction
    }

    ###########################################
    # Actions that happen within transactions #
    ###########################################

    action get_ledger_sequence returns (res: ledger) = {
        res := current_ledger
    }

    # TODO: record panic location?
    action panic = {
        require tx_has_started;
        tx_has_panicked := true;
        # TODO: why does ending the transaction immediately cause issues?
        # var _:bool;
        # _ := end_transaction();
    }

    ############################################
    # Actions that happen outside transactions #
    ############################################
    
    action increase_ledger_sequence = {
        require ~tx_has_started;
        current_ledger := ledger.next(current_ledger);
        ensure ~tx_has_started;
    }

    export increase_ledger_sequence

    conjecture [atomic_transactions_1] ~env.tx_has_started
    conjecture [atomic_transactions_2] ~env.tx_has_panicked
    conjecture [ledger_nonnegative] 0 <= env.current_ledger
}