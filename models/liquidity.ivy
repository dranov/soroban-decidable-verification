#lang ivy1.8

include liquidity_contract

type function_identifier = {
    _initialize,
    _share_id,
    _deposit,
    _swap,
    _withdraw,
    _get_rsrvs,

    _mint,
    _set_admin,
    _allowance,
    _approve,
    _balance,
    _spendable_balance,
    _transfer,
    _transfer_from,
    _burn,
    _burn_from
}
instance env : environment(function_identifier)
action panic = {
    call env.panic
}
# IMPORTANT: this must be instantiated after env, such that
# env's initializer runs first.
instance l : liquidity_contract

invariant [distinct_addresses] 
    l._this ~= l.a._this
    & l._this ~= l.b._this
    & l._this ~= l.share._this
    & l.a._this ~= l.b._this
    & l.a._this ~= l.share._this
    & l.b._this ~= l.share._this

# This is an interesting property, because it is only true if the
# LiquidityPool contract itself cannot own and withdraw pool shares.
# In that situation, withdrawing shares reduces the reserves,
# but doesn't actually change the balance of tokens.
# NOTE: this holds if people don't randomly transfer tokens to the LP.
# invariant [reserve_a_equals_balance]
#     (l.a.b.balance.pre(l._this) & l.a.b.balance.map(l._this, l.reserve_a.v))
#     | (~l.a.b.balance.pre(l._this) & l.reserve_a.v = integer.zero)

# You can have a larger balance than the reserve, but not a smaller one.
# (Larger because someone transfers the LP contract tokens outside of a deposit.)
invariant [reserve_a_lte_balance]
    (l.a.b.balance.pre(l._this) & (forall V. l.a.b.balance.map(l._this, V) -> integer.lte(l.reserve_a.v, V)))
    | (~l.a.b.balance.pre(l._this) & l.reserve_a.v = integer.zero)
invariant [reserve_b_lte_balance]
    (l.b.b.balance.pre(l._this) & (forall V. l.b.b.balance.map(l._this, V) -> integer.lte(l.reserve_b.v, V)))
    | (~l.b.b.balance.pre(l._this) & l.reserve_b.v = integer.zero)

attribute method = convert_to_mypyvy
