#lang ivy1.8

include liquidity_contract

type function_identifier = {
    _initialize,
    _share_id,
    _deposit,
    _swap,
    _withdraw,
    _get_rsrvs,

    _mint,
    _set_admin,
    _allowance,
    _approve,
    _balance,
    _spendable_balance,
    _transfer,
    _transfer_from,
    _burn,
    _burn_from
}
instance env : environment(function_identifier)
action panic = {
    call env.panic
}
# IMPORTANT: this must be instantiated after env, such that
# env's initializer runs first.
instance l : liquidity_contract

export l._execute_transaction
# ivy_check is pretty slow if all these are enabled
# export l.a._execute_transaction
# export l.b._execute_transaction
# export l.share._execute_transaction

invariant [distinct_addresses] 
    l._this ~= l.a._this
    & l._this ~= l.b._this
    & l._this ~= l.share._this
    & l.a._this ~= l.b._this
    & l.a._this ~= l.share._this
    & l.b._this ~= l.share._this

# This is an interesting property, because it is only true if the
# LiquidityPool contract itself cannot own pool shares. In that situation,
# withdrawing shares reduces the reserves, but doesn't actually change
# the balance of tokens.
invariant [reserve_a_equals_balance]
    (l.a.b.balance.pre(l._this) & l.a.b.balance.map(l._this, l.reserve_a.v))
    | (~l.a.b.balance.pre(l._this) & l.reserve_a.v = integer.zero)

invariant [reserve_b_equals_balance]
    (l.b.b.balance.pre(l._this) & l.b.b.balance.map(l._this, l.reserve_b.v))
    | (~l.b.b.balance.pre(l._this) & l.reserve_b.v = integer.zero)