#lang ivy1.8

include soroban

type money
function (X:money + Y:money) : money
function (X:money - Y:money) : money
interpret money -> int
# fragment checker complains if money -> int, so run `ivy_check complete=fo`
# alternative to this interpretation is to add some facts about + and -
# e.g. a + b >= a if b >= 0 etc.

type allowance_key = struct {
    owner : address,
    spender : address
}

type allowance_value = struct {
    amount : money,
    expiration_ledger : ledger
}

# admin.rs
object ad = {
    # DataKey::Admin (_admin_key is a singleton enum type)
    type _admin_key = { datakey_admin }
    invariant [admin_key_singleton]
        forall K1: _admin_key, K2: _admin_key. K1 = K2

    instance a : partial_map(_admin_key, address)
    action _save_state = {
        a._save_state()
    }
    action _restore_state = {
        a._restore_state()
    }

    action has_administrator returns (res : bool) = {
        res := a.has(datakey_admin)
    }

    action read_administrator returns (res : address) = {
        res := a.get(datakey_admin)
    }

    action write_administrator(new_admin : address) = {
        a.set(datakey_admin, new_admin)
    }
}

# allowance.rs
object al = {
    # FIXME: this is temporary storage
    instance allowance : partial_map(allowance_key, allowance_value)
    action _save_state = {
        allowance._save_state()
    }
    action _restore_state = {
        allowance._restore_state()
    }

    action read_allowance(owner : address, spender : address) returns (res : allowance_value) = {
        local key: allowance_key, v: allowance_value {
            key.owner := owner;
            key.spender := spender;
            if allowance.has(key) {
                v := allowance.get(key);
                if v.expiration_ledger < env.get_ledger_sequence() {
                    v.amount := 0;
                    res := v
                } else {
                    res := v;
                }
            } else {
                    v.amount := 0;
                    v.expiration_ledger := 0;
                    res := v
            }
        }
    }

    action write_allowance(owner : address, spender : address, amount : money, expiration_ledger : ledger) = {
        local v: allowance_value {
            v.amount := amount;
            v.expiration_ledger := expiration_ledger;

            if amount > 0 & expiration_ledger < env.get_ledger_sequence() {
                panic();
            }

            local key: allowance_key {
                key.owner := owner;
                key.spender := spender;
                # FIXME: model temporary storage
                allowance.set(key, v);

                if amount > 0 {
                    # FIXME: model temporary storage
                    # bump entry TTL
                }
            }
        }
    }

    action spend_allowance(owner : address, spender : address, amount : money) = {
        local v: allowance_value {
            v := read_allowance(owner, spender);
            if v.amount < amount {
                panic();
            }
            write_allowance(owner, spender, v.amount - amount, v.expiration_ledger);
        }
    }
}

# balance.rs
object b = {
    instance balance : partial_map(address, money)
    action _save_state = {
        balance._save_state()
    }
    action _restore_state = {
        balance._restore_state()
    }

    action read_balance(a : address) returns (res : money) = {
        if balance.has(a) {
            res := balance.get(a)
        } else {
            res := 0
        }
    }

    action write_balance(a : address, amount : money) = {
        balance.set(a, amount)
    }

    action receive_balance(a : address, amount : money) = {
        local balance : money {
            balance := read_balance(a);
            write_balance(a, balance + amount)
        }
    }

    action spend_balance(a : address, amount : money) = {
        local balance : money {
            balance := read_balance(a);
            if balance < amount {
                panic();
            }
            write_balance(a, balance + amount)
        }
    }
}

# TODO: should the above (admin, al, b) be modules instead of objects?
# TODO: metadata.rs

object token = {    
    action check_nonnegative_amount(amount : money) = {
        if amount < 0 {
            panic()
        }
    }

    action initialize(admin: address) = {
        if ad.has_administrator() {
            panic()
        }
        ad.write_administrator(admin)
        # TODO: metadata
    }

    action mint(to : address, amount : money) = {
        check_nonnegative_amount(amount);
        local admin: address {
            admin := ad.read_administrator();
            # FIXME: admin.require_auth()
            # FIXME: instance storage bump
            b.receive_balance(to, amount)
            # FIXME: env events
        }
    }

    action set_admin(new_admin : address) = {
        local admin: address {
            admin := ad.read_administrator();
            # FIXME: admin.require_auth()
            # FIXME: instance storage bump
            ad.write_administrator(new_admin)
            # FIXME: env events
        }
    }

    #############
    # INTERFACE #
    #############
    action allowance(owner : address, spender : address) returns (res : money) = {
        # FIXME: instance storage bump
        local allowance : allowance_value {
            allowance := al.read_allowance(owner, spender);
            res := allowance.amount
        }
    }

    action approve(owner : address, spender : address, amount : money, expiration_ledger : ledger) = {  
        # FIXME: owner.require_auth()
        check_nonnegative_amount(amount);
        # FIXME: instance storage bump
        al.write_allowance(owner, spender, amount, expiration_ledger)
        # FIXME: env events
    }

    action balance(id: address) returns (res: money) = {
        # FIXME: instance storage bump
        res := b.read_balance(id)
    }

    action spendable_balance(id: address) returns (res: money) = {
        # FIXME: instance storage bump
        res := b.read_balance(id)
    }

    action transfer(owner : address, to : address, amount : money) = {
        # FIXME: owner.require_auth()
        check_nonnegative_amount(amount);
        # FIXME: instance storage bump
        b.spend_balance(owner, amount);
        b.receive_balance(to, amount);
        # FIXME: env events
    }

    action transfer_from(spender : address, owner : address, to : address, amount : money) = {
        # FIXME: spender.require_auth()
        check_nonnegative_amount(amount);
        # FIXME: instance storage bump
        al.spend_allowance(owner, spender, amount);
        b.spend_balance(owner, amount);
        b.receive_balance(to, amount);
        # FIXME: env events
    }

    action burn(owner : address, amount : money) = {
        # FIXME: owner.require_auth()
        check_nonnegative_amount(amount);
        # FIXME: instance storage bump
        b.spend_balance(owner, amount);
        # FIXME: env events
    }

    action burn_from(spender : address, owner : address, amount : money) = {
        # FIXME: spender.require_auth()
        check_nonnegative_amount(amount);
        # FIXME: instance storage bump
        al.spend_allowance(owner, spender, amount);
        b.spend_balance(owner, amount);
        # FIXME: env events
    }

    # TODO: metadata: decimals, name, symbol
}

type tx_type = {
    initialize,
    mint,
    set_admin,
    allowance,
    approve,
    balance,
    spendable_balance,
    transfer,
    transfer_from,
    burn,
    burn_from
}

# Objects: ad, al, b, token
action execute_transaction = {
    env.begin_transaction();
    # Save state
    ad._save_state();
    al._save_state();
    b._save_state();
    local tx: tx_type, a: address, b: address, m: money {
        if tx = initialize {
            token.initialize(a);
        } else if tx = mint {
            token.mint(a, m);
            assert env.current_transaction.has_panicked -> m < 0;
        } else if tx = set_admin {
            token.set_admin(a);
        } else if tx = allowance {
            m := token.allowance(a, b);
        }
    }
    # Restore state; TODO: specification of restore
    var restore: bool;
    restore := env.end_transaction();
    if restore {
        ad._restore_state();
        al._restore_state();
        b._restore_state();
    }
}
export execute_transaction

conjecture [all_balances_positive]
    forall A, V.
        b.balance.pre(A) & b.balance.map(A, V) -> V >= 0