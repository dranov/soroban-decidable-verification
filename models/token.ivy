#lang ivy1.8

include token_contract

individual auth_assertion_failed : bool

after init {
    auth_assertion_failed := false
}

action end_transaction_hook = {
    if ~(forall O, M, NM, A. ~env.tx_has_panicked
        & t.b.balance.map(O, NM) & t.b.balance._map(O, M)
        & integer.lt(NM, M) # O's balance has decreased
        & integer.minus(M, NM, A) # A is the amount transfered
        & (env.tx_identifier = _transfer_from | env.tx_identifier = _burn_from)
        -> ((exists X. (env.auth_required(X, t._this, _transfer_from) |
                        env.auth_required(X, t._this, _burn_from))
            & env.historical_auth_required(O, t._this, _approve)))) {
                auth_assertion_failed := true;
    }
}

type function_identifier = {
    _initialize,
    _mint,
    _set_admin,
    _allowance,
    _approve,
    _balance,
    _spendable_balance,
    _transfer,
    _transfer_from,
    _burn,
    _burn_from
}
instance env : environment(function_identifier)
action panic = {
    call env.panic
}
# NOTE: order is important; this MUST be after env
instance t : token_contract

# Objects: ad, al, b, token
action execute_transaction = {
    local tx: function_identifier, _a: address, _b: address, _c: address, _m: integer, _l: ledger {
        env.begin_transaction(tx);
        t._save_state();

        if tx = _initialize {
            t.initialize(_a);
        } else if tx = _mint {
            t.mint(_a, _m);
            assert env.tx_has_panicked -> integer.lt(_m, integer.zero);
        } else if tx = _set_admin {
            t.set_admin(_a);
        } else if tx = _allowance {
            _m := t.allowance(_a, _b);
        } else if tx = _approve {
            t.approve(_a, _b, _m, _l);
        } else if tx = _balance {
            _m := t.balance(_a);
        } else if tx = _spendable_balance {
            _m := t.spendable_balance(_a);
        } else if tx = _transfer {
            t.transfer(_a, _b, _m);
        } else if tx = _transfer_from {
            t.transfer_from(_a, _b, _c, _m);
        } else if tx = _burn {
            t.burn(_a, _m);
        } else if tx = _burn_from {
            t.burn_from(_a, _b, _m);
        }


    # Assertions about authorization
    # (1) All balance-decreasing operations require authorization
    assert t.b.balance.map(O, NM) & t.b.balance._map(O, M)
        & integer.lt(NM, M) # O's balance has decreased
     -> (env.tx_has_panicked
        | (exists F. env.auth_required(O, t._this, F))
        | (exists X. (env.auth_required(X, t._this, _transfer_from) |
            env.auth_required(X, t._this, _burn_from))));

    # (2) transfer_from and burn_from have been previously approved
    # and authorized by the owner of the balance
    # TODO: turn this check into a state variable and state an
    # invariant that the state representing the assertion never becomes false
    assert ~env.tx_has_panicked
        & t.b.balance.map(O, NM) & t.b.balance._map(O, M)
        & integer.lt(NM, M) # O's balance has decreased
        & integer.minus(M, NM, A) # A is the amount transfered
        & (tx = _transfer_from | tx = _burn_from)
        -> ((exists X. (env.auth_required(X, t._this, _transfer_from) |
                        env.auth_required(X, t._this, _burn_from))
            & env.historical_auth_required(O, t._this, _approve)) # there was an approval
            # FIXME: this doesn't work; we should make Ivy print post-states
            # with trace=true to make it easier to debug what's going on
            # & (forall AK:allowance_key, AV:allowance_value, NAV:allowance_value.
            #     al.allowance.map(AK, NAV) & al.allowance._map(AK, AV)
            #     & AK.owner = O # there was an allowance from O
            #     # NOTE: if we want to say allowance from O to X, no longer in FAU
            #     & integer.gte(AV.amount, A) # allowance was sufficient
            #     & integer.minus(AV.amount, NAV.amount, A) # and decreases by the amount transfered (A)
            #  )
        );
    }

    # Restore state; TODO: specification of restore
    var restore: bool;
    restore := env.end_transaction();
    if restore {
        t._restore_state();
        assert t.b.balance.pre(X) = (old t.b.balance.pre(X));
        assert t.b.balance.map(X, Y) = (old t.b.balance.map(X, Y));
    }
}
# export execute_transaction

invariant [auth_assertion] ~auth_assertion_failed

attribute method = convert_to_mypyvy