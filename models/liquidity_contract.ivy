#lang ivy1.8

include soroban
include token_contract

module liquidity_contract = {
    individual _this : address
    after init {
        _this := env._register_contract();
    }

    # We convert each DataKey into a separate singleton
    # For TokenA, TokenB, and TokenShare, we have instances
    # rather than storing the address and having an indirection
    instance a : token_contract
    instance b : token_contract
    instance share : token_contract

    instance total_shares : singleton(integer)
    instance reserve_a : singleton(integer)
    instance reserve_b : singleton(integer)

    # constants in the contract
    individual residue_numerator : integer # = 997
    individual residue_denominator : integer # = 1000

    # The actual contract is modelled such that a, b, share
    # and so on can be unitialized, but that would complicate
    # modelling, so we assume LiquidityPool contracts are always
    # created initialized. This shouldn't be an issue, as
    # in the real contract, any operation on an uninitialized
    # contract would fail/panic.
    # This corresponds to fn initialize()
    after init {
        total_shares.set(integer.zero);
        reserve_a.set(integer.zero);
        reserve_b.set(integer.zero);

        # We don't model the actual number, just their relationship.
        assume 
            residue_numerator ~= integer.zero & residue_denominator ~= integer.zero
            & integer.lt(residue_numerator, residue_denominator);
    }

    action share_id returns (res : address) = {
        res := share._this;
    }

    action deposit(depositor: address, desired_a: integer, min_a: integer, desired_b: integer, min_b: integer) = {
        # `depositor` is called `to` in the contract code
        env.require_auth(depositor, _this, _deposit);
        local _reserve_a:integer, _reserve_b:integer,
            _amount_a:integer, _amount_b:integer,
            _balance_a:integer, _balance_b:integer,
            _total_shares:integer, _new_total_shares:integer {

            _reserve_a := reserve_a.get();
            _reserve_b := reserve_b.get();

            # Calculate deposit amounts
            (_amount_a, _amount_b) := get_deposit_amounts(desired_a, min_a, desired_b, min_b, _reserve_a, _reserve_b);
            # FIXME: model auth for cross-contract call
            a.transfer(depositor, _this, _amount_a);
            b.transfer(depositor, _this, _amount_b);

            # Calculate how many new pool shares to mint
            _balance_a := get_balance_a();
            _balance_b := get_balance_b();
            _total_shares := total_shares.get();

            _new_total_shares := integer.zero;
            if integer.gt(_reserve_a, integer.zero) & integer.gt(_reserve_b, integer.zero) {
                local  _shares_a: integer, _shares_b: integer {
                    _shares_a := integer.div(integer.mul(_balance_a, _total_shares), _reserve_a);
                    _shares_b := integer.div(integer.mul(_balance_b, _total_shares), _reserve_b);
                    _new_total_shares := integer.min(_shares_a, _shares_b);
                }
            } else {
                # NOTE: it's not crucial that this is the sqrt;
                # it just has good properties.
                _new_total_shares := integer.sqrt(integer.mul(_balance_a, _balance_b));
            }
        }
    }

    action swap(to: address, buy_a: bool, out: integer, in_max: integer) = {
        env.require_auth(to, _this, _swap);
        local _reserve_a:integer, _reserve_b:integer,
            _reserve_sell:integer, _reserve_buy:integer,
            _n:integer, _d:integer, _sell_amount:integer,
             _balance_a:integer, _balance_b:integer,
            _out_a:integer, _out_b:integer,
            _new_inv_a:integer, _new_inv_b:integer,
            _old_inv_a:integer, _old_inv_b:integer {

            _reserve_a := reserve_a.get();
            _reserve_b := reserve_b.get();

            if buy_a {
                _reserve_sell := _reserve_b;
                _reserve_buy := _reserve_a;
            } else {
                _reserve_sell := _reserve_a;
                _reserve_buy := _reserve_b;
            }

            # First calculate how much needs to be sold to buy amount `out`
            _n := integer.mul(integer.mul(_reserve_sell, out), residue_denominator);
            _d := integer.mul(integer.sub(_reserve_buy, out), residue_numerator);
            _sell_amount := integer.add(integer.div(_n, _d), integer.one);

            if integer.gt(_sell_amount, in_max) {
                panic();
            }

            if buy_a {
                b.transfer(to, _this, _sell_amount);
            } else {
                a.transfer(to, _this, _sell_amount);
            }

            _balance_a := get_balance_a();
            _balance_b := get_balance_b();

            _out_a := integer.zero;
            _out_b := integer.zero;
            if buy_a {
                _out_a := out;
            } else {
                _out_b := out;
            }

            _new_inv_a := new_invariant_factor(_balance_a, _reserve_a, _out_a);
            _new_inv_b := new_invariant_factor(_balance_b, _reserve_b, _out_b);
            _old_inv_a := integer.mul(residue_denominator, _reserve_a);
            _old_inv_b := integer.mul(residue_denominator, _reserve_b);

            if integer.lt(integer.mul(_new_inv_a, _new_inv_b), integer.mul(_old_inv_a, _old_inv_b)) {
                panic();
            }

            if buy_a {
                a.transfer(_this, to, _out_a);
            } else {
                b.transfer(_this, to, _out_b);
            }
        }

    }


    # Internal functions
    action get_deposit_amounts(desired_a: integer, min_a: integer, desired_b: integer, min_b: integer, reserve_a: integer, reserve_b: integer)
     returns (res_a: integer, res_b: integer) = {
        if reserve_a = integer.zero & reserve_b = integer.zero {
            res_a := desired_a;
            res_b := desired_b;
            # return (desired_a, desired_b)
        } else {
            local amount_a:integer, amount_b: integer {
                amount_b := integer.div(integer.mul(desired_a, reserve_b), reserve_a);
                if integer.lte(amount_b, desired_b) {
                    if integer.lt(amount_b, min_b) {
                        panic();
                    }
                    res_a := desired_a;
                    res_b := amount_b;
                    # return (desired_a, amount_b)
                } else {
                    amount_a := integer.div(integer.mul(desired_b, reserve_a), reserve_b);
                    if integer.gt(amount_a, desired_a) | integer.lt(desired_a, min_a) {
                        panic();
                    }
                    res_a := amount_a;
                    res_b := desired_b;
                    # return (amount_a, desired_b)
                }
            }
        }
    }

    action new_invariant_factor(balance: integer, reserve: integer, out: integer)
     returns (res: integer) = {
        local _delta:integer, adj_delta:integer {
            _delta := integer.sub(integer.sub(balance, reserve) , out);
            adj_delta := integer.zero;
            if integer.gt(_delta, integer.zero) {
                adj_delta := integer.mul(residue_numerator, _delta);
            } else {
                adj_delta := integer.mul(residue_denominator, _delta);
            }
            res := integer.add(integer.mul(residue_denominator, reserve), adj_delta);
        }   

    }

    action get_balance_a returns (res: integer) = {
        # FIXME: model auth for cross-contract call
        res := a.balance(_this);
    }

    action get_balance_b returns (res: integer) = {
        # FIXME: model auth for cross-contract call
        res := b.balance(_this);
    }
}

# instantiate liquidity_contract